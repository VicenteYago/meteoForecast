---
title: "AEMET API"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = TRUE)
knitr::opts_knit$set(root.dir = '~/Desktop/WatermedR/')
```

```{r}
library(httr)
library(tidyverse)
library(lubridate)
library(readxl) # read xls 
raw.route<-"./raw_data/"
```

En este documento se pretende investigar la funcionalidad de la API REST de AEMET y encapsular toda la logica para hacer todo el proceso de forma sistematica.

Lo primero que hay que hacer es conseguir una KEY: 
https://opendata.aemet.es/centrodedescargas/altaUsuario
Te la mandan al correo.

```{r}
KEY <- "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb3NldmljZW50ZS55YWdvQHVtLmVzIiwianRpIjoiNTdhNDgwMzQtNDYxNy00OWZmLWFiMjgtZjZlMjBjZjliOGUwIiwiaXNzIjoiQUVNRVQiLCJpYXQiOjE1ODcwMjY5NzQsInVzZXJJZCI6IjU3YTQ4MDM0LTQ2MTctNDlmZi1hYjI4LWY2ZTIwY2Y5YjhlMCIsInJvbGUiOiIifQ.huWKTwOwU-XCMv4DwHJCzNs8zQn8L2cO834ltpiUymM"
```

Para conseguir datos, primero hay que especificar de que lugar, en este servicio se determinan estaciones meteorologicas por municipios. 

Catalogo de servicios: https://opendata.aemet.es/centrodedescargas/inicio
                       https://opendata.aemet.es/dist/index.html


## PREDICCIÓN ESPECÍFICA MUNICIPIO HORARIA

Para conseguir la predicción hay que saber el codigo de municipio, que se puede averiguar de la siguiente web: 
https://www.ine.es/daco/daco42/codmun/codmunmapa.htm

```{r}
codmun <- paste0(raw.route, "20codmun03.xls") %>% read_excel()
codmun<-codmun[3:nrow(codmun),]
names(codmun) <- c("CPRO", "CMUN", "DC", "NOMBRE")
codmun

"./"
```

Me interesa la parcela piloto, que esta muy cerca de Villena:

```{r}
codmun[codmun$NOMBRE == "Villena",]
```

En el siguiente enlace se pueden ver las predicciones especificas: 

https://opendata.aemet.es/dist/index.html#!/predicciones-especificas/Predicci%C3%B3n_por_municipios_horaria_Tiempo_actual

El codigo de municipio necesario se forma con la concatenación de los campos: CPRO + CMUN

```{r}
codigo<-paste0(codmun[codmun$NOMBRE == "Villena", c("CPRO")], codmun[codmun$NOMBRE == "Villena", c("CMUN")])
print(codigo)
```


OJO!. Igualmente he sacado el codigo de Mula: 30029
```{r}
codigo <- "30029"
```



Aqui se hace el primer get especificando unicamente el codigo y la KEY, en el enlace de arriba se especifica cual es la URL y los posibles codigos de respuesta.

```{r}
DIR <- paste0("https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/horaria/", codigo)
r<-GET(DIR,
      add_headers(content_type = "application/json"),
      add_headers('api_key' = KEY))
r$status_code
content <- content(r)
content
```

Aquí vemos como resultados unos links en los que podemos consultar tanto los datos como los metadatos, en formato JSON.


### DATOS

```{r}
r <-GET(content$datos,
      add_headers(content_type = "application/json"),
      add_headers('api_key' = KEY))
r$status_code
content <- content(r)

tmpfile <- tempfile(pattern = "", tmpdir = "./tmp", fileext = ".json") # TODO
content %>% write(file = tmpfile)
aemet <- RJSONIO::fromJSON(tmpfile)
unlink(tmpfile)
```

Aqui podemos ver todas las predicciones disponibles:

```{r}
aemet[[1]]$prediccion$dia[[1]] %>% names()
```

* Las mas intersantes son:
  - precipitacion
  - probTormenta
  - temperatura
  - sensTermica
  - humedadRelativa
  - vientoAndRachaMax

El caso del viento es especial, se especifica tanto el:
 - viento (supongo que viento medio por hora)
 - RachaMax (racha maxima de viento alcanzada dentro de una hora concreta, siempre es superior al viento medio)  


Con este codigo se extran los datos de json, se transforman a dataframe y se plotean:

Prediccion de temperatura:

```{r}
df.glob <- data.frame()
for (i in 1:length(aemet[[1]]$prediccion$dia)){
  aemet[[1]]$prediccion$dia[[i]]$fecha %>% as.POSIXct() -> d1
  data.frame(
    hour  = d1 + hours(aemet[[1]]$prediccion$dia[[i]]$temperatura %>% lapply("[[", "periodo") %>% unlist() %>% as.numeric()),
    value = aemet[[1]]$prediccion$dia[[i]]$temperatura %>% lapply("[[", "value") %>% unlist() %>% as.numeric()
  ) -> df
  df.glob <- rbind(df.glob,df)
}
```

```{r}
ggplot(data = df.glob, aes(x = hour, y = value)) + 
  geom_point() +
  geom_line() + 
  labs(x = "Time", y = "ºC") + ggtitle("Predicción temperatura AEMET 48 horas")
```



El resultado de la predicción es curioso:

> La predicción abarca 48 horas. 
> La prediccion siempre empieza a las 08:00 AM del dia en el que se realiza la petición. Esto provoca que esas 48 horas abarquen 3 dias:
  - Parte del dia en el que se hace la predicción: [08:00 - 23:00]  (16 horas)
  - El dia siguiente completo : [00:00 - 23:00] ( 24 horas)
  - Parte del dia siguiente : [00:00 - 07:00] (8 horas)




# ENCAPSULANDO API REST

Aqui tengo una funcion que se encarga de compilar los datos de diferentes variables, esta diseñada para trabajar concretamente con:
> temperatura
> humedad relativa
> precipiataciones
> viento 

El viento es un caso especial pues la API ofrece tanto el viento medio por hora y la maxima racha por hora (m/s). Actualmente el algoritmo esta
programado unicamente para obtener el viento medio por hora.

```{r}

aemetJSONtodf <- function(aemet.JSON, variable){
  df.glob <- data.frame()
  for (i in 1:length(aemet.JSON[[1]]$prediccion$dia)){
    aemet.JSON[[1]]$prediccion$dia[[i]]$fecha %>% as.POSIXct() -> d1
  
    if (variable == "viento"){
      
      (1:(aemet.JSON[[1]]$prediccion$dia[[i]]$vientoAndRachaMax %>% length()))[c(T,F)] -> idx.viento # los indices pares son rachaMax
      
      data.frame(
        hour =  d1 + hours(aemet.JSON[[1]]$prediccion$dia[[i]]$vientoAndRachaMax[idx.viento] %>% lapply("[[", "periodo") %>% unlist() %>% as.numeric()),
        value =            aemet.JSON[[1]]$prediccion$dia[[i]]$vientoAndRachaMax[idx.viento] %>% lapply("[[", "velocidad") %>% unlist() %>% as.numeric()
      ) -> df  
    
        
    } else {
      data.frame(
        hour  = d1 + hours(aemet.JSON[[1]]$prediccion$dia[[i]][[variable]] %>% lapply("[[", "periodo") %>% unlist() %>% as.numeric()),
        value =            aemet.JSON[[1]]$prediccion$dia[[i]][[variable]] %>% lapply("[[", "value") %>% unlist() %>% as.numeric()
      ) -> df
    }
    
    
    df.glob <- rbind(df.glob,df)
  }
  return(df.glob)
}

getPrediccionAEMET<-function(codigo, KEY){
  
  # Returns link to json data
  DIR <- paste0("https://opendata.aemet.es/opendata/api/prediccion/especifica/municipio/horaria/", codigo)
  r<-GET(DIR,
         add_headers(content_type = "application/json"),
         add_headers('api_key' = KEY))
  r$status_code
  content <- content(r)
  
  # Returns raw json data
  r <-GET(content$datos,
      add_headers(content_type = "application/json"),
      add_headers('api_key' = KEY))
  r$status_code
  content <- content(r)

  tmpfile <- tempfile(pattern = codigo, tmpdir = "./tmp", fileext = ".json") # puede fallar si no hay directorio tmp
  content %>% write(file = tmpfile)
  aemet <- RJSONIO::fromJSON(tmpfile)
  unlink(tmpfile)
  
  temp  <- aemetJSONtodf(aemet, "temperatura")
  HR    <- aemetJSONtodf(aemet, "humedadRelativa")
  prec  <- aemetJSONtodf(aemet, "precipitacion")
  viento<- aemetJSONtodf(aemet, "viento") 
  
  df <- data.frame(date = temp[,1],
                   temp  = temp[,2],
                   HR    = HR[,2],
                   prec  = prec[,2],
                   viento = viento[,2]/3.6)
  
  return(df)
}

res <- getPrediccionAEMET(codigo, KEY)
```

Aquí podemos ver las predicciones: 

```{r}
ggplot(res, aes(x = date)) + 
  geom_line(aes(y = temp))+ggtitle("Prediccion temperatura 48 h AEMET") + labs( y = "ºC")

ggplot(res, aes(x = date)) + 
  geom_line(aes(y = HR))+ggtitle("Prediccion humedad relativa 48 h AEMET")+ labs( y = "%")

ggplot(res, aes(x = date)) + 
  geom_line(aes(y = prec))+ggtitle("Prediccion precipitacion 48 h AEMET") + labs( y = "mm")

ggplot(res, aes(x = date)) + 
  geom_line(aes(y = viento)) +ggtitle("Prediccion viento 48 h AEMET")+ labs( y = "m*s^-1")
```


Ejemplo de como hacer la invocacion desde la funcion cargada desde la libreria:

```{r}
source("./notebooks/custom_libs/aemet_API.R")
codigo <- "30029"
pred <- getPrediccionAEMET("03122")
pred
```




